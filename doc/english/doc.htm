<html><!-- InstanceBegin template="/Templates/MainTemplate.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<!-- #BeginEditable "doctitle" -->
<title>Jdon Framework document</title>  
<!-- #EndEditable -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="shortcut icon" href="http://www.jdon.com/favicon.ico">
<!-- InstanceBeginEditable name="head" -->

-->
</style>
<!-- InstanceEndEditable -->
<link href="views.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#dddddd" text="#000000">
 <table width="100%" border="0" cellspacing="0" cellpadding="0" align="center">

  <tr> 
    <td height="11" colspan="7" bgcolor="#FFFFFF" class="bianxian"> 
      <table width="100%" border="0" cellspacing="0" cellpadding="0" height="1" bordercolor="#000000">
        <tr> 
          <td> 
            <table width="100%" border="0" cellspacing="0" cellpadding="0" height="200" bgcolor="#000000" background="images/background.jpg">
              <tr> 
                <td></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <tr> 
    
    <td bgcolor="#FFFFFF"  valign="top">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td valign="top" width="100"><table width="100%" border="0" cellspacing="0" cellpadding="3" height="200" align="center">
      <tr>
        <td align="right"><table width="100%" height="200" border="0" align="center" cellpadding="3" cellspacing="0" dwcopytype="CopyTableCell">
            <tr>
              <td align="left"  valign="top"><p align="center"><img src="images/jdone.gif" width="120" height="60" border="0"></p>
                  <p ><B><a href="https://sourceforge.net/projects/jdon/files/" target="_blank">Download</a></B>                  </p>
                  <p ><B><a href="doc.htm" target="_blank">Document</a></B></p>
                  <p ><a href="quickconf.html"><strong>Qucik Start</strong></a> </p>
                  <p ><a href="https://github.com/banq/jdonframework/tree/master/example" target="_blank"><strong>Examples</strong></a></p>
                  <p ><a href="https://github.com/banq/jdonframework"><strong>Github</strong></a></p>
<p ><B><a href="http://sourceforge.net/projects/jdon/files/jivejdon/4.x/" target="_blank">jivejdon</a></B></p>
                  <p ><a href="http://code.google.com/p/jdonmvc/downloads/list"><strong>JdonMVC</strong></a></p>
                  <p ><a href="http://www.jdon.com/jdonframework/"><strong>Jdon中文</strong></a></p>
<p >&nbsp;</p>

<p >Twitter:
  <br >
  <a href="https://twitter.com/jdonframework" target="_blank"><strong>@jdonframework</strong></a></p>
                  <!-- InstanceBeginEditable name="Menu" --> <!-- InstanceEndEditable --> </td>
            </tr>
        </table></td>
        </tr>
      </table></td>
         
          <td valign="top" > 
            <table width="100%" border="0" cellspacing="2" cellpadding="2">
              <tr>
                <td>
                  
				<!-- #BeginEditable "main" --> 
                  <h1 align="center">Jdon Framework Document </h1>
                 
                    <p> Before  Domain-Driven Design(DDD) appears , business logic was directly implemented by  technical component , such as  a service or a action and so on. these model objects were all anaemia model (<a href="http://www.javacodegeeks.com/2013/06/the-biggest-flaw-of-spring-web-applications.html" title="Permalink to The Biggest Flaw of Spring Web Applications" target="_blank" rel="bookmark">The Biggest Flaw of Spring Web Applications</a>), anaemia model just is a data collection, and Service   components drive the anaemia models to complete some business logics. this model was called &quot;Transaction script&quot;.</p>
                    <p>                      Domain-driven design (DDD)  is different from traditional script. all domain logics are in Domain model, Domain model drives  technical components to do technical something that not about business, domain model is like DNA. </p>
                    <p>So DDD architecture can focus on  business domain model that is easy  to understand, in the mean time, domain model also makes  our software systems more scalable,and be better performance.</p>

                    <p>DDD is an approach to developing software for complex needs by deeply connecting the implementation to an evolving model of the core business concepts,</p>
                    <p>servral concepts are the Heart and Soul of OOD, these concepts you must understand before using jdon:</p>
                  <pre>   Bounded context
   Aggregate Root
   Entities and Identity, Value Objects 

 </pre>
 <div class="adsensf" id="vgad336x280">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 页上左336 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-7573657117119544"
     data-ad-slot="6751585519"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>          
                    <h2> In Memory Domain model </h2>
                    <p>domain model  mainly includes the Entity,Value  Object and Service that all focus on the  business domain,it is nothing to do with the concrete technical  implementation. but we need let them living in the technical  system.</p>
                    <p>In Jdon Framework, these domain models are marked with the @Model  annotation, so they are in memory and     send asynchronous events or message to the consumers .</p>
                    <p><img src="images/domainevents.png" width="606" height="349" alt="de"></p>
                  <p><br>
                    domain model is the core of our  software systems,their lifecycles management is very important, Jdon Framework more easily makes better  management about domain model's lifecycles , domain model lives  in the in-memory cache ,such as guava(default) or ehcache,oscache,terracotta ....,so the software  system can scale to a distributed cache system ,such as  terracotta ,memcached or other gird products.</p>
                    <p><br>
                      However,cache is a very low-level  technical layer,if we allow the developers to manually interact with  cache,then it will easily lead to errors and inconsistecies,so Jdon Framework  integrates two interceptors ,one is &quot;CacheInterceptor&quot; ,the other is &quot;DomainCacheInterceptor&quot;,they  both was configured in the &quot;aspect.xml&quot; file which is a config file  packed with  Jdon Framework.</p>
                    <p>DomainCacheInterceptor is between domain layer(domain model live in this layer) and repository  layer, when we fetch a domain model(@model) from repository  layer,  DomainCacheInterceptor will intercept the invocation(locate the method such as &quot;get*()&quot;), and check  the model object if  be in the cache,if that is,DomainCacheInterceptor just return the cached Model object ,or else  it will put the model object  retrieved from  repository/persistence datasource into the cache.</p>
                    <p><br>
                      Last let me see the followed diagram,the  diagram describes the relation of the two interceptors. </p>
                    <p>&nbsp;</p>
                    <p><img src="images/6.2.model.cache.arch.png" alt="aa" width="651" height="364"> </p>
                    <p> CacheInterceptor only work when you use jdon-struts:</p>
                    <p>&quot;CacheInterceptor&quot;  is between the presentation layer and  business layer,when the presentation action invoke the &quot;get*()&quot; method  of business service,the CacheInterceptor will intercept the invocation,it first  checks  that whether the domain model  object already is the cache,if the model object is not in  cache,CacheInterceptor will invoke the next interceptor which is in the interceptor  chain,and finally the model object will be fetched from persistence  datasource,the CacheInterceptor will gain the fetched model object and put it  into the cache.</p>
                    <p></p>
                    <h3>how to let model in memory?</h3>
                  <p>jdon provides some annotations to assist developer to do that, at first you must annotate @Model with your Aggregate Root Entity that can be accessed from outside such technical components:</p>
                  <div>
                    <div>@Model&#13;</div>
                    <div>public class MyModel {&#13;</div>
                    <div> &nbsp;&nbsp;&nbsp;private String userId;&#13;</div>
                    <div>&nbsp;&nbsp;&nbsp;private String name;&#13;</div>
                    <div>     ....&#13;</div>
                    <div>}&#13;</div>
                    <div></div>
                  </div>
                  <p>MyModel is a Aggregate Root Entity inside a bounded context. you can't create the entity object by &quot;new MyModel()&quot;, only fetch it from repository, so jdon provides some annotations to configure in repository.</p>
                  <p>Second step: configure in repository</p>
                  <p>@Introduce(“modelCache”) is annotated in 
   repository class:</p>
                  <p><img src="images/introducecache.png" width="416" height="208" alt="cachge"></p>
                  <p>there are three annotations: @Component @Introduce and @Around.</p>
                  <p>@Component is for normal  components(technical or application), any class with @Component can be managed by IOC container. Jdon Ioc container is based on pico container, only supports class construt injection.</p>
                  <p>@Introduce is about aop interceptor, that means introduces a interceptor into here(at front of the class instance), the interceptor name is modelCache that configured in aspect.xml packed with jdon. if you don't like the name (&quot;modelCache&quot;), you can modify it in aspect.xml .</p>
                  <p>@Around is the target method that will be intercepted. target method can be like &quot;getXXX&quot; or &quot;findById&quot;(jdon allows any method name), and its return class type must be the entity annotated with @Model(this is a jdon constraint).</p>
                  <p>in the mehtod annotated with @Around, you can fetch the model from Relation  or NoSQL Database, you can use JDBC or other ORM ( JDBC is recommended). you can use jdon -jdbc lib.</p>
                  <p>finally we can find a model(@Model) by these code:</p>
                  <p>MyModel myModel = repository.getModel(new Long(100));</p>
                  <p>myModel object is actual proxy instance that created by our interceptor &quot;modelCache&quot;, when you first times got it, &quot;modelCache&quot; will locate it in Cache, if miss it will load it from your repository, if hit it directly return the myModel.</p>
                  <p>when you got a myModel, you can invoke its any methods, but if you call a method with(@Oncommand), it is different with direct method invoking.</p>
                  <p>&nbsp;</p>
                  <p>&nbsp;</p>
                  <h2>Command and Event</h2>
                  <p> Command or Event is a communication way between domain model and components, at first we need know how much components type there are in jdon.</p>
                  <h3>&nbsp;</h3>
                  <h3>Basic components</h3>
                  <p>There are five components model in Jdon Framework, they are:</p>
                  <div>
                    <div>1. Entity Model with @Model;&#13;</div>
                    <div>2. Service with @Service;&#13;technical component</div>
                    <div>3. Component with @Component ;&#13;technical component</div>
                    <div>4. Prodcuer-Consumer mode with @Send @Consumer;&#13;</div>
                    <div>5. Interceptor with @ Interceptor, need with @Introduce;&#13;</div>
                    <div> All  in com.jdon.annotation.*&#13;</div>
                    <div></div>
                  </div>
                  <p>As mentioned above,Jdon Framework seperates the  application architecture into two parts:Domain models and technical components  . so these two components are our basic. we will often use  them.</p>
                  <p>Domain model is annotated with @Model , it is a aggregate root entity in a bounded context, you can got them using DDD.</p>
                  <p>Component annotated with @Component is others except domain model. include technical or application, they lives in  the IOC container. can autowiring injected each other by their constrution. dependency injection is tight coupling although it is better than inheritance, we can use loose coupling producer-consumer mode.</p>
                  <p>Any invoking between aggregate root(AR) and Component must use producer-consumer mode. that keeps our business logics are loose coupling with technical infrastructure, these is a core function of jdon.</p>
                  <p>Service  annotated with @Service is mico service that represents bounded context, or a DDD service that across multiple entities. Service also like other components live in Ioc container, it can be @stateful or @poolable.</p>
                  <p>Now we know: domain models(@Model) lives in the cache ,and the technical components(@Service/@Component) lives in  the IOC container. their communications are producer-consumer.</p>
                  <p>  Component's lifecycles  management is also important,jdon  use pico container to manage their  lifecycles, the container is also  holded in the context container such as the ServeltContext or your application root.</p>
                  <p>you can use @Inject to inject   component into  domain model. but it is only for introducing domain events, not recommended for other usage.</p>
                  <p>&nbsp;</p>
                  <h3>differnce with Command and Event</h3>
                  <p>When a Component/Service sends messages to a Domain Model(aggregate root),  we call the message is a command, and when a domain model send message to a Component,  it is reactive  a event.:</p>
                  <p><img src="images/commandevent.png" alt="command event" width="530" height="300"></p>
                  <p>　　A command actions the behavior(startMatch) of a aggregate root(domain model), and a event happend in this behavior, the event will be sent to another aggregate root or a Component that maybe save it to repository.</p>
                  <p><img src="images/actor.png" alt="actors model" width="499" height="168"></p>
                  <p>Jdon provide four kinds of asynchronous concurrency communication(Producer/Consumer) with these two models.</p>
                  <p>　　1. Component -----&gt; model</p>
                  <p>　　2. model -------&gt;Component</p>
                  <p>　　3. Compponent ------&gt; Component</p>
                  <p>　　4. model------&gt; model</p>
                  <p>&nbsp;</p>
                  <h3>Command</h3>
                  <p>in a typal Web application , we have this flow: UI ---Command---&gt; a aggregate root(AR) ---Events --&gt;Component:</p>
                  <p><img src="images/CQRS1.png" alt="" width="333" height="243"></p>
                  <p>A command will change a state in a AR, but in a web application there are many concurent request, contention will happen,  There is a lot of research in computer science for managing this contention that boils down to 2 basic approaches. One is to provide mutual exclusion to the contended resource while the mutation takes place; the other is to take an optimistic strategy and swap in the changes if the underlying resource has not changed while you created the new copy.(see details: <a href="http://www.javacodegeeks.com/2012/08/single-writer-principle.html" target="_blank">Single Writer Principle</a>)</p>
                  <p>contention:</p>
<p><img src="images/contention.png" alt="" width="300" height="376"></p>
<p>Blocking  (lock )</p>
<p><img src="images/lock.png" alt="" width="800" height="265"></p>
<p>mutual exclusion:</p>
<p><img src="images/lock2.png" alt="" width="800" height="348"></p>
<p>Noblocking single writer:</p>
<p><img src="images/singlewrite.png" alt="" width="370" height="221"></p>
<p> Jdon provides a nonblocking single writer to change AR's state, LMAX disruptor is its Infrastructure，</p>
<p>if a AR's method annotated with @OnCommand , it is a action for command from UI. only a single thread call the method.</p>
<p>@Model<br>
public class AggregateRootA {</p>
<p>     private int state = 100;</p>
<p>    @<strong>OnCommand</strong>(&quot;CommandtoEventA&quot;) <br>
  　public Object save(ParameterVO parameterVO) {</p>
<p>         //update root's state in non-blocking single thread way (Single Writer)<br>
  　　this.state = parameterVO.getValue() + state;</p>
<p>       　. .</p>
<p>    }</p>
<p>}</p>
<p>this AggregateRootA is a Consumer, Producer is in Service or CommandHandler:</p>
<p>Producer: </p>
<p><br>
  public interface AService {</p>
<p> 　　@<strong>Send</strong>(&quot;CommandtoEventA&quot;)<br>
  　　public DomainMessage commandA(@Owner String rootId, @Receiver AggregateRootA model, <br>
  　　　　　　　　　　　　　　　　int newstate);<br>
  } </p>
<p>Producer emits message to its Consumer by a asynchronous and non-blocking queue made by LMAX Disruptor's RingBuffer.
  @Send(&quot;CommandtoEventA&quot;) ---&gt; @OnCommand(&quot;CommandtoEventA&quot;) </p>
<p>client  code:</p>
<p>AggregateRootA myModel = repository.getModel(new Long(100));</p>
<p>AService aService = webappUtil.getService(&quot;aService&quot;);</p>
<p>aService.commandA(&quot;100&quot;, myModel, 200);//change AggregateRootA state to 200;</p>
<p>&nbsp;</p>
<p>this invoking way is thread safe, and have high througout and lower lantency, it is like Actors model in Scala, or like Netty's IO. it is nonblocking and asynchronous.</p>
<p>in these mode, there are two kinds of Consumer in jdon:</p>
<p> @Send --&gt; @OnCommand  (1:1 Queue)<br>
  @Send --&gt; @OnEvent    (1:N topic)</p>
<p>difference between 'OnCommand' and 'OnEvent' is:</p>
<p>when a event happend otherwhere comes in a aggregate root we regard this event
  as a command, and it will action a method annotated with @OnCommand, 
  and in this method some events will happen. and they will action those methods annotated with @OnEvent.</p>
<p>&nbsp;</p>
<h3>Domain Events </h3>
                    <p>Domain Events is that events that happend in domain, wo can call it is reactive event. </p>
                    <p>Domain Events  is essential  to solve the interaction between the domain  model and the technical component,Jdon  apply  domain events pattern  to make  domain model less coupling with technical components. </p>
                    <p>domain events will react when a command comes in :</p>
                    <p><img src="images/CQRS.png" width="387" height="330"></p>
                    <p>&nbsp;</p>
                    <p>As the above diagram description,when Command comes in domain models trigger some domain events,the domain event will generate proper  domain message,at last the messageListener will treat with the event,and assist  with some operations infrastructure such as saving DB.</p>
                  <p>Because a command will react a domain event, so if we saving these domain events, be equals to saving those commands, and later we can replay these events, this is called Event Sourcing, there are some EventSoucing database (functional database/Event Store, such as GETEventStore).</p>
                    <p>Domain Event have  Producer-Consumer(1:1) and Publisher-Subscriber(1:N) patterns: Domain Model is a producer; it send events or message to Consumer:</p>
                    <p>@Send(topicName) =&gt; @Consumer(topicName);</p>
                    <p>if there are many consumers, their started order is by their class name's alphabetical . such <strong>A</strong>EventHandler is first be reaction; and then <strong>B</strong>EventHandler and <strong>C</strong>Eve.......<br>
                    </p>
                    <h3>How to use Domain Events</h3>
                    <p><br>
                      If you want to use Domain event ,you  just need to use three Annotations,@Introduce,@Inject and @Send.for example,we  have a model class named MyModel,and a domain event named MyDomainEvent ,the  code is as here:</p>
                    <table width="90%" border="0" bgcolor="#CCCCCC">
                      <tr>
                        <td><p>@Model <br>
                              <strong>public</strong> <strong>class</strong> MyModel { </p>
                          <p> &nbsp;&nbsp;&nbsp;<strong>private</strong> Long id; <br>
                            <strong>&nbsp;&nbsp;&nbsp;private</strong> String name; </p>
                          <p>&nbsp;&nbsp;&nbsp;@<strong>Inject</strong><br>
                            <strong>&nbsp;&nbsp;&nbsp;private</strong> MyModelDomainEvent myModelDomainEvent;                          </p>
                          <p>&nbsp;&nbsp;&nbsp;<strong>public</strong> String getName() { <br>
                            <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</strong> (<strong>this</strong>.name == <strong>null</strong>) { </p>
                          <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this is async method, can be splite twice times calling. <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventMessage message = myModelDomainEvent.asyncFindName(<strong>this</strong>); <br>
                            <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this</strong>.name = (String)  message.getEventResult(); <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  <br>
                            <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</strong> name; <br>
                            } </p>
                          <p>…… <br>
                          }</p>
                          <p>@Introduce(&quot;message&quot;) <br>
                              <strong>public</strong> <strong>class</strong> MyModelDomainEvent { </p>
                          <p>&nbsp;&nbsp;&nbsp;@Send(value=&quot;MyModel.findName&quot;,asyn=<strong>true</strong>) <br>
                            <strong>&nbsp;&nbsp;&nbsp;public</strong> DomainMessage asyncFindName(MyModel  myModel) { <br>
                            <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</strong> <strong>new</strong> DomainMessage(myModel); <br>
                               } </p>
                        <p>}</p></td>
                      </tr>
                    </table>
                    <p>When you fetch a MyModel instance from service  or repository, because of @<strong>Inject</strong>,  CacheInterceptor or DomainCacheInterceptor will inject  MyModelDomainEvent  into the MyModel instance,When injecting the  MyModelDomainEvent, jdon find MyModelDomainEvent class has annotation with @Introduce(&quot;message&quot;) , then will  at first load   MessageInterceptor(in aspect.xml message=MessageInterceptor),and last return a proxy instance .</p>
                    <p>When we call myModel proxy instance, such as invoke its method &quot;myModel.getName()&quot;, the MessageListenner will  intercept our invocation,it will choose proper means to drive the  MessageListner to response invocation request.</p>
                    <p>full domain events example is in here:<a href="match.html">DDD CQRS EventSourcing example source: football Match</a></p>
                    <p>wo can use domain events to model the requirement, see <a href="ces.html"><strong>CES:Context Event and State</strong></a></p>
                    <p>and <a href="http://www.slideshare.net/ziobrando/model-storming-a-different-approach-to-collaborative-model-discovery-vilnius-edition" target="_blank">Model Storming</a></p>
                    <p><a name="fourway"></a></p>
                    <h2>Producer/Consumer</h2>
                    <p>Jdon provide four kinds of asynchronous concurrency communication(Producer/Consumer) with these two models.</p>
                    <p>　　1. Component -----&gt; model (that is a Command)</p>
                    <p>　　2. model -------&gt;Component (that is a event)</p>
                    <p>　　3. Compponent ------&gt; Component (that is event)</p>
                    <p>　　4. model------&gt; model (commands and events)</p>
                    <p>here is Summary:</p>
                    <h3>1. Component =&gt; Model</h3>
                    <p> 　　Component(producer with @Component) -- &gt; Model(consumer with @Model)</p>
                    <p>　　this mode is for CQRS's Command, one command is sent from UI, and sent to one aggregate root, one command has one action on the method of the aggregate root. this mode  works.</p>
                    <p>　　in this mode producer:consumer can only be 1:1, one command can only be sent to one method of one domain model. </p>
                    <p>　　The A in this sample is a producer with @Component:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>&nbsp;</p>
                          <p>package com.jdon.sample.test.command;</p>
                          <p>import com.jdon.annotation.model.Send;</p>
                          <p>public interface AICommand {</p>
                          <p> 　@<strong>Send</strong>(&quot;CommandmaTest&quot;)<br>
                            　public TestCommand ma(<strong>@Receiver </strong>BModel bModel);<br>
                            <br>
                            }<br>
                          </p>
                          <p>@<strong>Component</strong>(&quot;producer&quot;)<br>
                            @<strong>Introduce</strong>(&quot;componentmessage&quot;)<br>
                            public class A implements AICommand {</p>
                          <p> 　public TestCommand ma(BModel bModel) {<br>
                            　　System.out.print(&quot;send to BModel =&quot; + bModel.getId());<br>
                            　　return new TestCommand(99);<br>
                            　}<br>
                            }</p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　the method &quot;ma&quot; annotated with @Send must have a method parameter:BModel that annotated with @Model, that means send a command message to this domain model , the model is a receiver for a command, so must annotate with <strong>@Receiver</strong>.</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p><br>
                          @<strong>Model</strong><br>
                          public class BModel {<br>
                          private String id;</p>
                          <p> 　private int state = 100;</p>
                          <p> 　public BModel(String id) {<br>
                            　　super();<br>
                            　　this.id = id;<br>
                            　}</p>
                          <p> 　@<strong>OnCommand</strong>(&quot;CommandmaTest&quot;)<br>
                            　public void save(TestCommand testCommand) {<br>
                            　　this.state = testCommand.getInput() + state;<br>
                            　　testCommand.setOutput(state);</p>
                          <p> 　}</p>
                          <p> 　public String getId() {<br>
                            　　return id;<br>
                            　}</p>
                          <p> 　public void setId(String id) {<br>
                            　　this.id = id;<br>
                            　}</p>
                          <p>}<br>
                          </p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　the topic name &quot;CommandmaTest&quot;  is  unique; because  producer : consumer is 1:1. one command has one action(onCommand). @<strong>OnCommand</strong> is annotated on the method of consumer.</p>
                    <p>　　the procuder(AICommand) 's ma method commands the consumer(BModel)'s save method. AICommand is a Component and BModel is a Model.</p>
                    <p>　　below is the client code:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"> AppUtil appUtil = new AppUtil();<br>
                          AICommand a = (AICommand) appUtil.getComponentInstance(&quot;producerforCommand&quot;);<br>
                          BModel bModel = new BModel(&quot;one&quot;);<br>
                          TestCommand testCommand = a.ma(bModel);<br>
                          int i = 0;<br>
                          long start = System.currentTimeMillis();<br>
                          while (testCommand.getOutput() != 199) {<br>
                          i++;<br>
                          }<br>
                          long stop = System.currentTimeMillis();<br>
                          Assert.assertEquals(testCommand.getOutput(), 199);<br>
                          System.out.print(&quot;ok &quot; + &quot;  &quot; + (stop - start));</td>
                      </tr>
                    </table>
                    <p>　　it output:</p>
                    <p>　　send to BModel =oneok   5</p>
                    <p>　　above source in :<a href="https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/command">https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/command</a></p>
                    <p>　　in this mode the component receives any commands from UI or others events, and handles them to a aggregate root :</p>
                    <p>　　UI -------&gt;commandHandler(@Component) ------&gt;aggregate root model</p>
                    <p> 　　in this mode, @Model is a actor and representing Aggregate Root , the state of aggregate root is changed by only single thread, it is threadsafe. and no blocking and no lock, like Actors mode of AKKA or ERlang, or like Node.js EDA. instead of 2PC or JTA, this mode can make transaction work well in high throughput way. </p>
                    <p>　　When we apply Jdon in a web application,  the system  works something like this:</p>
                    <ul>
                      <li>Some command comes in to modify a given Aggregate Root (AR) entity</li>
                      <li>If an @Model representing the AR is not already running in the system, create it _atomically_ (i.e. make sure you never have more than one @Model representing a specific entity)</li>
                      <li>@Model should be removed after a period of idleness. This will avoid keeping actors around for entities with low interaction rates, but ensure 'hot' entities are kept in memory for performance (starting a new @Model requires loading events from an event store in order to restore the memory image representing the entity state), all these things are be done by cache in jdon. see below : @Introduce(&quot;modelCache&quot;)</li>
                    </ul>
                    <p>&nbsp;</p>
                    <h3>2.Model =&gt; Component</h3>
                    <p><strong>　　</strong>Model(producer with @Model) -- &gt; Component(consumer with @Component)</p>
                    <p>　　After a agrregate root (domain model) receive a command , and it will reactive a event that can be sent to a Component or another aggregate root. we call it is domain events.</p>
                    <p> 　　we can inject a Component(<strong>with </strong> @Component) into a agrregate root that acts as a producer.</p>
                    <p>　　the domain model code:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>@<strong>Model</strong><br>
                          public class MyModel {</p>
                          <p> 　private Long id;<br>
                            　private String name;</p>
                          <p> 　@<strong>Inject</strong> //inject the Component into this domain model<br>
                            　private MyModelDomainEvent myModelDomainEvent;</p>
                          <p>　public String getName() {<br>
                            　　if (this.name == null) {<br>
                            　　　DomainMessage message = myModelDomainEvent.asyncFindName(this);<br>
                            　　　this.name = (String) message.getBlockEventResult();<br>
                            　　}<br>
                            　　return name;<br>
                            　} </p>
                          <p>....</p>
                          <p>}</p></td>
                      </tr>
                    </table>
                    <p>　　we inject MyModelDomainEvent into &quot;MyModel&quot; with @<strong>Inject</strong>, the injected object &quot;MyModelDomainEvent&quot; is a Component:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>package com.jdon.sample.test.domain.simplecase;</p>
                          <p>import com.jdon.annotation.Introduce;<br>
                            import com.jdon.annotation.model.Send;<br>
                            import com.jdon.domain.message.DomainMessage;</p>
                          <p>@<strong>Introduce</strong>(&quot;message&quot;)<br>
                            public class MyModelDomainEvent {</p>
                          <p> 　@<strong>Send</strong>(&quot;MyModel.findName&quot;)<br>
                            　public DomainMessage asyncFindName(MyModel myModel) {<br>
                            　　return new DomainMessage(myModel);<br>
                            　}</p>
                          <p> 　@<strong>Send</strong>(&quot;saveMyModel&quot;)<br>
                            　public DomainMessage save(MyModel myModel) {<br>
                            　　return new DomainMessage(myModel);<br>
                            　}</p>
                          <p>}<br>
                          </p></td>
                      </tr>
                    </table>
                    <p>　　MyModelDomainEvent is annotated with @<strong>Introduce</strong>(&quot;message&quot;),  in this producer class there are two topic that means two kinds of domain events.</p>
                    <p>　　let's see how to implement a consumer for a domain event. the consumer is too a Component, see below:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>@<strong>Consumer</strong>(&quot;MyModel.findName&quot;)<br>
                          public class FindNameListener implements <strong>DomainEventHandler</strong> {</p>
                          <p> 　public void <strong>onEvent</strong>(EventDisruptor event, boolean endOfBatch) throws Exception {<br>
                            　　MyModel myModel = (MyModel) event.getDomainMessage().getEventSource();<br>
                            　　System.out.println(&quot;Asynchronous eventMessage=&quot; + myModel.getId());<br>
                            　　event.getDomainMessage().setEventResult(&quot;Asynchronous eventMessage=&quot; + 　　myModel.getId());<br>
                            　}<br>
                            }<br>
                          </p></td>
                      </tr>
                    </table>
                    <p>　　FindNameListener is annotated with @<strong>Consumer</strong>, not @<strong>Component</strong>, this is another consumer style, when using @<strong>Consumer</strong>, we need implement a interface <strong>DomainEventHandler</strong>, and implement its method <strong>onEvent</strong>, if we using @<strong>Component</strong>, we need use @<strong>OnEvent</strong> together.</p>
                    <p>　　above consumer is for the producer @<strong>Send</strong>(&quot;MyModel.findName&quot;), another consumer for this producer @<strong>Send</strong>(&quot;saveMyModel&quot;) of this sample uses @Component and @OnEvent:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>@<strong>Component</strong>(&quot;mymrepository&quot;)<br>
                          @Introduce(&quot;modelCache&quot;)<br>
                          public class RepositoryImp implements MyModelRepository {</p>
                          <p> 　@Around<br>
                            　public MyModel getModel(Long key) {<br>
                            　　MyModel mym = new MyModel();<br>
                            　　mym.setId(key);<br>
                            　　return mym;<br>
                            　}</p>
                          <p> 　@<strong>OnEvent</strong>(&quot;saveMyModel&quot;)<br>
                            　public void save(MyModel myModel) {<br>
                            　　System.out.print(&quot;\n No.1 @OnEvent:&quot; + this.getClass().getName());</p>
                          <p> 　}</p>
                          <p>}</p></td>
                      </tr>
                    </table>
                    <p>　　this consumer is a class RepositoryImp that it is a Repository of DDD, and it also fetch a aggregate root from repository, @Introduce(&quot;modelCache&quot;) and @Around enable in-memory cache before the database. only when there is no the model object in cache, it will got from the database. @Introduce(&quot;modelCache&quot;) and @Around is necessary for using jdon framework. if not use them, any domain events will disable.</p>
                    <p>　　another way,we can call com.jdon.domain.dci.RoleAssigner assignAggregateRoot method to let any normal object be act as a aggregate root.</p>
                    <p>　　the in-memory cache make Aggregate Root living in memory, you can configure any cache product(ehcache, Redis ) for it. ensure 'hot' entities are kept in memory for performance.</p>
                    <p>　　we have known about two interactive modes between Component and aggregate root, if using these two modes in a aggregate root, it can be regarded as a Actors mode like Akka or Erlang: </p>
                    <ul>
                      <li> Share NOTHING, </li>
                      <li>Isolated lightweight event-based processes, </li>
                      <li>Each actor has a mailbox (message queue, in jdon it is Disruptor of LMAX)<br>
                      </li>
                      <li>Communicates through asynchronous&amp;  non-blocking message passing</li>
                    </ul>
                    <p>　　above sources: <a href="https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/domain/simplecase">https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/domain/simplecase</a></p>
                    <p>&nbsp;</p>
                    <h3>3.Component =&gt; Component</h3>
                    <p><strong>　　</strong>Component(producer with @Component) -- &gt; Component(consumer with @Component)</p>
                    <p>　　in this mode there are two ways:</p>
                    <p>　　1. dependency inject </p>
                    <p>　　2. producer and consumer based on Event.</p>
                    <p>　　Dependency inject is like IOC, Jdon only supports class construtor inject:</p>
                    <table width="650" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>&nbsp;</p>
                          <p>@Component<br />
                            public class A{</p>
                          <p>　　private B b;</p>
                          <p>　　//inject b instance<br />
                            　　public A(B b){<br />
                            　　　this.b = b;<br />
                            　　} <br />
                            }</p>
                          <p>@Component<br />
                            public class B{</p>
                          <p>}</p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　after B was injected into A, A can directly invoke any B's method. another way is more loose couple,between A and B there are communicates through asynchronous&amp;  non-blocking message passing  .</p>
                    <p>　　The A in this sample is a producer with @Component:</p>
                    <p>&nbsp;</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>&nbsp;</p>
                          <p>package com.jdon.sample.test.event;</p>
                          <p>import com.jdon.annotation.model.Send;</p>
                          <p>public interface AI {</p>
                          <p>　　@<strong>Send</strong>(&quot;maTest&quot;)<br>
                            　　public TestEvent ma();<br>
                            }</p>
                          <p>&nbsp;</p>
                          <p>@<strong>Component</strong>(&quot;producer&quot;)<br>
                            @<strong>Introduce</strong>(&quot;componentmessage&quot;)<br>
                            public class A implements AI {</p>
                          <p> 　public TestEvent ma() {<br>
                            　　System.out.print(&quot;event.send.ma..&quot;);<br>
                            　　return new TestEvent(99);<br>
                            　}<br>
                            }</p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　The B in this sample is a consumer with @Component, and its consumer method must be annotated with @<strong>OnEvent</strong>,</p>
                    <p>&nbsp;</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>&nbsp;</p>
                          <p>@<strong>Component</strong>(&quot;consumer&quot;)<br>
                            public class B {</p>
                          <p> 　@<strong>OnEvent</strong>(&quot;maTest&quot;)<br>
                            　public void mb(TestEvent testEvent) throws Exception {<br>
                            　　testEvent.setResult(testEvent.getS() + 1);//the consumer return a result to the procuder<br>
                            　　System.out.print(&quot;event.@OnEvent.mb..&quot; + testEvent.getResult() + &quot;\n&quot;);<br>
                            　　Assert.assertEquals(testEvent.getResult(), 100);<br>
                            　}<br>
                            }</p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　the value &quot;maTest&quot; of @<strong>OnEvent</strong> must be same as the value of @<strong>Send</strong>. and the return type &quot;TestEvent&quot; of the method with @<strong>Send</strong> must be same as the input paramter type of the @<strong>OnEvent</strong>, so the producer can handle a object to the consumer.</p>
                    <p>　　if the consumer want to return a result to the producer, recommend to use method setEventResult of <a href="https://github.com/banq/jdonframework/blob/master/src/main/java/com/jdon/domain/message/DomainMessage.java" target="_blank">com.jdon.domain.message.DomainMessage</a>, and the producer can fetch the result by its getBlockEventResult() or getEventResult(), getBlockEventResult() can block until get the result.</p>
                    <p>&nbsp;</p>
                    <p>　　Test client code:</p>
                    <table width="750" border="0">
                      <tr>
                        <td bgcolor="#CCCCCC"><p>&nbsp;</p>
                          <p>&nbsp;</p>
                          <p> AppUtil appUtil = new AppUtil();<br>
                            AI a = (AI) appUtil.getService(&quot;producer&quot;);<br>
                            TestEvent te = a.ma();<br>
                            long start = System.currentTimeMillis();<br>
                            while (te.getResult() != 100) {<br>
                            }<br>
                            long stop = System.currentTimeMillis();</p>
                          <p> Assert.assertEquals(te.getResult(), 100);<br>
                            System.out.print(&quot;ok &quot; + &quot;  &quot; + (stop - start) + &quot;\n&quot;);</p>
                          <p></p>
                          <p></p></td>
                      </tr>
                    </table>
                    <p>　　output:</p>
                    <p> 　　[junit] event.send.ma..event.@OnEvent.mb..100<br>
                      [junit] ok   31</p>
                    <p>　　above codes is from<a href="https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/event">https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/event</a></p>
                    <p>&nbsp;</p>
                    <h3>4.Model =&gt; Model</h3>
                    <p><strong>　　</strong>Model(aggregate root A) -- &gt; Model(aggregate root B)</p>
                    <p>　　Aggregates
                      are
                      always
                      internally
                      consistent, and Aggregates&quot;eventually
                      consistent&quot;  with
                      each
                      other.
                      – Asynchronous<br>
                      updates
                      propagate
                      through
                      system,References are 
                      limited
                      to
                      aggregate
                      roots.</p>
                    <p>　　when a aggregates root want to cal another aggregates root , it only can be implemented by domain events, a output event act as a input command for another aggregates root.</p>
                    <p>　　this mode consists of  three modes above:</p>
                    <p>　　1. Aggrgate root A reactive a event to a Component (model ---&gt; Component)</p>
                    <p>　　2.the Component transfer the event to a command for Aggrgate root B (Component ----&gt;Component)</p>
                    <p>　　3.the command will be sent to Aggrgate root B (component --&gt;model)</p>
                    <p>　　this mode's source code is in Github: <a href="https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/cqrs" target="_blank">https://github.com/banq/jdonframework/tree/master/src/test/java/com/jdon/sample/test/cqrs</a></p>
                    <p>&nbsp;</p>
<h2>DCI</h2>
<p>DCI: Data, Context, Interactions is a programming paradigm invented by Trygve Reenskaug. the domain model is a Data, the domain events producer is a Role of DCI, it includes the interactions of DCI. </p>
<p>Jdon Framework's domain model injection function can inject the role into the domain model, such as above the class UserDomainEvents is a Role, it can be injected into the model UserModel.so it help UserModel implements business function ComputeCount. In runtime, The Role UserDomainEvents will be injected into the Data UserModel.<br>
  <br>
  <a href="http://jivejdon.blogspot.com/2011/09/ddd-dci-and-domain-events-example.html"><strong>DDD DCI and Domain Events example</strong></a> </p>
<p><br> 
  DCI Example:<a href="http://code.google.com/p/jivejdon/downloads/detail?name=SimpleJdonFrameworkTest.rar&amp;can=2&amp;q=">SimpleJdonFrameworkTest.rar</a> </p>
<h2>AOP</h2>
                    <p>Using the  DDD,It is the domain models drive the  technical components to finish the business logics,and in this design style,the  components are just the assistants,which assist the domain models to complete  the business operations.So how the domain models gain the needed  components,Jdon framework use the @Inject and @Component to inject components  and the domain events into models.<br>
                  </p>
                    <p>As the followed diagram illustrates  ,when client invoke the getA(&quot;a&quot;),if Model A with a Introduce,the A  will be enhanced,and the technical component C will also be injected  into the A ,at the same time,when inject the  B,the B will also be enhanced for the @Introduce.</p>
                    <p><img src="images/6.2.model.png" width="704" height="396"></p>
                    <p>&nbsp;</p>
                    <h3><a href="springIntegration.html">How to integrate Jdon Framework  with Spring</a></h3>
                    <h3><a href="ces.html"><strong>CES:Context Event and State</strong></a></h3>
                    <h2>&nbsp;</h2>
                    <h2><strong>Ioc container</strong></h2>
                    <P><br>
                      The great thing about objects is they can be replaced.
                      ----Object-
                      Oriented Analysis and Design with Applications, Grady Booch,
                      one of the
                      founding fathers of object-oriented programming</P>
                    <P>The great thing about Jdon is it helps you replace them((even
                      you can replace jdon itself!).</P>
                    <P>All framework components
                      include framework infrastructure objects are be managed
                      by a micocontainer made by <a href="http://www.picocontainer.org/%20" target="_blank">Picocontainer</a>,
                      you can insert or change any components by change the
                      xml configuration files(such as container.xml/aspect.xml/jdonframework.xml),
                      you can also replace Jdon framework's infrastructure  components(this
                      is a strongpoint). </P>
                    <P>Jdon framework will make your components. the infrastructure
                      components or POJO services collaborate with each other
                      via <A href="ioc.html">dependency
                        injection</A>. </P>
                    <P>When you have hundreds of components/POJO services, Jdon's
                      autowiring function will take care of their invocation
                      relation.</P>
                    <P><strong>Interceptor</strong> : <br>
                      You can insert a Interceptor by XML files aspect.xml, Jdon
                      has some default interceptos, they are  pool interceptor/cache
                      interceptor/stateful interceptor.this interceptos will
                      active before target services are invoked.if you appont
                      a interceptor to a service, the service must implements
                      the interface the interceptor, such as Poolable or Stateful </P>
                    <P><strong>Service/Componet</strong>:<br>
                      When you want to develop a small system, you
                      can only use POJO services implement logic function. How to  get a service instance? two ways: Annotation or XML</P>
                    <P>XML :</P>
                    <P>in jdonframework.xml (container.xml)
                      there is such service  configuration:</P>
                    <table width="100%"  border="0" cellpadding="1" cellspacing="0" bgcolor="#CCCCCC">
                      <tr>
                        <td><P>&lt;pojoService name=&quot;userDao&quot; class=&quot;news.container.UserJdbcDao&quot;&gt;</P>
                            <p>&lt;constructor value=&quot;java:/NewsDS&quot;/&gt;</p>
                          <p>&lt;/pojoService&gt;</p></td>
                      </tr>
                    </table>
                    <P>in code, we can get the service instance by below mode:</P>
                    <table width="100%"  border="0" cellpadding="1" cellspacing="0" bgcolor="#CCCCCC">
                      <tr>
                        <td> UserDao ud = (UserDao)WebAppUtil.getService(“userDao”); </td>
                      </tr>
                    </table>
                    <P>Jdon defines four service models: component instance that
                      is singleton, service instance that can be pooled</P>
                    <P>about Choice with Annotaion and XML in Ioc container:XML in IoC containers:<a href="http://www.theserverside.com/news/thread.tss?thread_id=56989" target="_blank"> A Hell or A Realm? </a></P>
                    <P><strong>Service Annotaion</strong></P>
                    <P> @Poolable: get a instance from the class's  object pooing, <a href="http://michael-bien.com/mbien/entry/object_pooling_determinism_vs_throughput" target="_blank">Object Pooling - Determinism vs. Throughput</a><br>
                        <br>
                      @Stateful:its instance lifecycle is user session scope <br>
  <br>
                      @Singleton: get a singleton instance form the class </P>
                    <P><strong>RAD Tool</strong>(jdon-struts1x)</P>
                    <P>Keep deliberately simple, yet still very powerful, so
                      that your code is kept simple.</P>
                    <P> Jdon  provides a fast development
                      way for model's CRUD(create/read/update/delete) , in presentation
                      layer, in general, you don't need any code, only configure MVC   Process  in
                      the jdonframework.xml:</P>
                    <table width="100%"  border="0" cellpadding="1" cellspacing="0" bgcolor="#CCCCCC">
                      <tr>
                        <td><pre > &lt;model key=&quot;userId&quot; <br>    class =&quot;com.jdon.framework.test.model.UserTest&quot;&gt;<br>      &lt;actionForm name=&quot;userActionForm&quot;/&gt;<br>      &lt;handler&gt;<br>        &lt;service ref=&quot;testService&quot;&gt; <br>          &lt;getMethod name=&quot;getUser&quot; /&gt;<br>          &lt;createMethod name=&quot;createUser&quot; /&gt;<br>          &lt;updateMethod name=&quot;updateUser&quot; /&gt;<br>          &lt;deleteMethod name=&quot;deleteUser&quot; /&gt;<br>        &lt;/service&gt;<br>      &lt;/handler&gt;<br>    &lt;/model&gt;</pre >                        </td>
                      </tr>
                    </table>
                    <P>Jdon's presentation layer is based Struts 1.2, so Jdon
                      will generate Action instance at running time.</P>
                    <P>Multi page query function can be accomplished quickly
                      by Jdon, Jdon provide the multi-page taglib,  JDBC template,
                      and Model's cache optimization.</P>
                    <P>Use Jdon, you can develop a small system in several minutes,
                      here is the system demo:<a href="http://www.jdon.com:8080/testWeb/" target="_blank">http://www.jdon.com:8080/testWeb/</a> </P>
                    <P><a href="steps.html" target="_blank">Step by Step develop a Jdon application with jdon-struts1x</a> </P>
                    <h2>&nbsp;</h2>
                  <p>for jdon old version  :                  </p>
                  <p><a href="struts_jdon_jdbc.html"><strong>How to develop Struts-Jdon-JDBC Application</strong></a></p>
                  <p><a href="command.html"><strong>Command patern for calling services</strong></a></p>
                  <h3><a href="jdonMovie.htm">Struts + Jdon + Hibernate video</a></h3>
<H3>Blog</H3>
<H3><strong><a href="DomainEvents.html">DDD</a></strong> <a href="DomainEvents.html"><strong>DCI</strong> and <strong>Domain</strong> <strong>Events</strong> <strong>example</strong></a></H3>
<H3><a href="dci.html">how to enhance Jdon framework to DCI framework ? </a></H3>
<H3><a href="Immutability.html">Immutability is everything </a></H3>
<H3><a href="non-blocking.html">how to easily develop a non-blocking concurrent application ? </a></H3>
<p>&nbsp;</p>
<p>&nbsp;</p>
                  <!-- #EndEditable -->
                 
			    </td>
              </tr>
            </table>			
          </td>
		  <td width="340" valign="top"  bgcolor="#FFFFD7"> 
          <div class="adsensf" id="vgad336x280">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 页上左336 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-7573657117119544"
     data-ad-slot="6751585519"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 页上左336 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-7573657117119544"
     data-ad-slot="6751585519"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</div>         
   </td>
      </tr>
    </table></td>
  </tr>
</table>


<table width="100%" border="0" cellspacing="0" cellpadding="0" height="2" bgcolor="#000000"  align="center">
              <tr>
                <td></td>
              </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="center">
<tr><td height="20" bgcolor="#CAC9BB" align="center">
  <p><span class="small"><font color="#555555"><br>
  </font></span></p>
  </td>
</tr>
</table>
<br>
<!-- InstanceBeginEditable name="EditRegion3" --><!-- InstanceEndEditable -->
</body>
<!-- InstanceEnd --></html>
